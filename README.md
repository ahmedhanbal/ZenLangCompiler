# ZenLang — Lexical Analyser

**Course:** CS4031 — Compiler Construction  
**Assignment:** 01 — Lexical Analyser Implementation  
**Language:** ZenLang | **Extension:** `.lang`

---

## Team Members

| Name | Roll Number |
|------|-------------|
| Ahmed Ali Zahid | 22i-1271 |
| Asad Mehdi | 22i-1120 |

**Section:** C

---

## Language Overview

ZenLang is a custom educational programming language designed to teach compiler construction concepts. It features a clean, keyword-driven syntax with strong typing conventions.

### Keywords (12)

| Keyword | Meaning |
|---------|---------|
| `start` | Begin a block or function |
| `finish` | End a block or function |
| `loop` | While-style loop |
| `condition` | If-statement |
| `else` | Else branch |
| `declare` | Variable declaration |
| `output` | Print to console |
| `input` | Read from console |
| `function` | Function declaration |
| `return` | Return from function |
| `break` | Exit loop early |
| `continue` | Skip to next iteration |

### Identifier Rules

- **Must start with** an uppercase letter `A–Z`
- **Followed by** zero or more: lowercase letters, digits, underscores
- **Maximum length:** 31 characters
- **Cannot** be a reserved keyword

```
Valid:   Count   Total_sum   X   Result_2024
Invalid: count   _Var   2Count   myVariable
```

### Literals

| Type | Format | Examples |
|------|--------|---------|
| Integer | `[+-]?[0-9]+` | `42`, `-567`, `+100` |
| Real | `[+-]?[0-9]+\.[0-9]{1,6}([eE][+-]?[0-9]+)?` | `3.14`, `1.5e10`, `-2.0E-3` |
| Text (String) | `"..."` with escapes | `"Hello"`, `"Line1\nLine2"` |
| Character | `'.'` with escapes | `'A'`, `'\n'`, `'\''` |
| Boolean | `true` or `false` | `true`, `false` |

**String/Char escape sequences:** `\"` `\\` `\n` `\t` `\r`

### Operators

| Category | Operators |
|----------|-----------|
| Arithmetic | `+` `-` `*` `/` `%` `**` |
| Relational | `==` `!=` `<` `>` `<=` `>=` |
| Logical | `&&` `\|\|` `!` |
| Assignment | `=` `+=` `-=` `*=` `/=` `%=` |
| Increment | `++` |
| Decrement | `--` |

### Comments

```
## This is a single-line comment

#*
   This is a
   block comment
*#
```

---

## Sample Programs

### 1. Hello World

```
start
    output "Hello, ZenLang!"
finish
```

### 2. Sum of 1 to N

```
start
    declare N = 10
    declare Sum = 0
    declare I = 1

    loop (I <= N)
        Sum += I
        I++
    finish

    output "Sum = ", Sum
finish
```

### 3. Function with Recursion

```
start function Factorial(N)
    condition (N <= 1)
        return 1
    finish
    return N * Factorial(N - 1)
finish

start
    declare Result = Factorial(5)
    output "5! = ", Result
finish
```

---

## Compilation & Execution

### Manual Scanner (ManualScanner.java)

```bash
# Compile
cd src
javac TokenType.java Token.java SymbolTable.java ErrorHandler.java ManualScanner.java

# Run on a test file
java ManualScanner ../tests/test1.lang

# Output includes: token stream, statistics, identifier table, errors
```

### JFlex Scanner

```bash
# Generate scanner from flex spec
cd src
jflex Scanner.flex        # generates Yylex.java

# Compile everything
javac *.java

# Run
java Yylex ../tests/test1.lang
```

---

## Project Structure

```
├── src/
│   ├── TokenType.java        # Token category enum
│   ├── Token.java            # Token data class
│   ├── SymbolTable.java      # Symbol/identifier tracking
│   ├── ErrorHandler.java     # Error detection & reporting
│   ├── ManualScanner.java    # Main DFA-based scanner
│   ├── Scanner.flex          # JFlex specification
│   └── Yylex.java            # Generated by JFlex (placeholder)
├── docs/
│   └── Automata_Design.pdf   # DFA diagrams & full report
├── tests/
│   ├── test1.lang            # All valid token types
│   ├── test2.lang            # Complex expressions
│   ├── test3.lang            # String/char escape sequences
│   ├── test4.lang            # Lexical error cases
│   ├── test5.lang            # Comment processing
│   └── TestResults.txt       # Expected outputs
├── README.md                 # Project overview
└── LanguageGrammar.txt       # Formal grammar specification
```

---

## Test Files

| File | Purpose |
|------|---------|
| `test1.lang` | All valid token types — no errors expected |
| `test2.lang` | Complex nested expressions and functions |
| `test3.lang` | String and character literals with escapes |
| `test4.lang` | Intentional lexical errors — tests error recovery |
| `test5.lang` | Comment processing (line and block) |

---

## Implementation Notes

- **DFA-based** token recognition with longest-match principle
- **Pattern priority** strictly followed (block comments → line comments → multi-char ops → keywords → booleans → identifiers → reals → integers → strings → chars → single ops → delimiters → whitespace)
- **Error recovery:** all errors logged, scanning continues to find all issues
- **Line/column tracking** accurate for all token types including multi-line block comments
- **Identifier table** tracks name, type (unknown until semantic phase), first occurrence, and occurrence count
